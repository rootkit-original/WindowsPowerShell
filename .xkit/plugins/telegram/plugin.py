"""
XKit Telegram Plugin
Plugin integrado com MCP Server para comunica√ß√£o completa com Telegram Bot
"""
import asyncio
from typing import Dict, Any, List, Optional, Callable
from pathlib import Path

from .base import XKitCorePlugin
from ..infrastructure.telegram_service import TelegramService
from ..infrastructure.config import XKitConfigService
from ..core.ports.event_port import IEventService
from ..domain.entities import ProjectInfo, DevelopmentContext
from ..mcp.client import XKitMCPClient


class TelegramPlugin(XKitCorePlugin):
    """Plugin integrado com MCP Server para Telegram Bot"""
    
    def __init__(self):
        super().__init__(
            name="telegram",
            version="2.0.0", 
            description="ü§ñ Telegram Bot integrado com MCP Server para controle remoto completo"
        )
        self.telegram_service: Optional[TelegramService] = None
        self.config_service: Optional[XKitConfigService] = None
        self.event_service: Optional[IEventService] = None
        self.mcp_client: Optional[XKitMCPClient] = None
        
        # MCP Integration
        self._telegram_server_active = False
    
    async def _initialize_services(self) -> None:
        """Inicializa os servi√ßos do plugin e MCP Server"""
        # Registra servi√ßos
        self.config_service = XKitConfigService()
        self.register_service("config", self.config_service)
        
        # Inicializa cliente MCP
        await self._setup_mcp_client()
        
        # Configura Telegram se dispon√≠vel
        await self._setup_telegram()
        
        # Registra handlers de eventos
        if self.event_service:
            await self._register_event_handlers()
    
    async def _setup_mcp_client(self) -> None:
        """Inicializa cliente MCP e servidor Telegram"""
        try:
            self.mcp_client = XKitMCPClient()
            
            # Tenta ativar o servidor telegram-bot
            available_servers = await self.mcp_client.list_servers()
            
            if "telegram-bot" in available_servers:
                # Testa conex√£o com servidor MCP Telegram
                result = await self.mcp_client.call_tool(
                    "telegram-bot", "get-bot-info", {}
                )
                
                if result.get("success"):
                    self._telegram_server_active = True
                    print("üöÄ MCP Telegram Server ativado!")
                else:
                    print(f"‚ö†Ô∏è MCP Telegram Server com problemas: {result.get('error')}")
            else:
                print("‚ö†Ô∏è MCP Telegram Server n√£o encontrado")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao inicializar MCP Client: {e}")
    
    async def _setup_telegram(self) -> None:
        """Configura o servi√ßo Telegram baseado na configura√ß√£o"""
        telegram_config = self.config_service.get_section("telegram")
        
        if not telegram_config:
            # Cria configura√ß√£o padr√£o
            default_config = {
                "enabled": False,
                "token": "",
                "admin_id": "",
                "notifications": {
                    "project_analysis": True,
                    "anomalies": True,
                    "startup": True,
                    "mcp_integration": True
                },
                "message_format": "markdown",
                "mcp_server_enabled": True,
                "webhook": {
                    "enabled": False,
                    "url": "",
                    "secret_token": ""
                }
            }
            self.config_service.set("telegram", default_config)
            self.config_service.save_config()
            
            # Mensagem de propaganda XKit v3.0 üéâ
            print("ü§ñ Plugin Telegram v2.0 carregado!")
            print("ÔøΩ Agora com MCP Server integrado!")
            print("ÔøΩüìù Configure em ~/.xkit/config.json:")
            print("   telegram.token = 'seu_bot_token'")
            print("   telegram.admin_id = 'seu_chat_id'")
            print("üí° Crie seu bot com @BotFather no Telegram!")
            print("üîå Use comandos remotos: /analyze, /status, /git")
            return
        
        # Inicializa servi√ßo se configurado
        if telegram_config.get("enabled", False):
            token = telegram_config.get("token")
            admin_id = telegram_config.get("admin_id")
            
            if token and admin_id:
                self.telegram_service = TelegramService(token, admin_id)
                self.register_service("telegram", self.telegram_service)
                
                if self.telegram_service.is_available():
                    print("ü§ñ Telegram Bot conectado!")
                    await self._send_startup_message()
                    
                    # Setup MCP Server webhook if enabled
                    if telegram_config.get("mcp_server_enabled") and self._telegram_server_active:
                        await self._setup_mcp_webhook()
                else:
                    print("‚ö†Ô∏è Telegram configurado mas n√£o dispon√≠vel")
            else:
                print("‚ö†Ô∏è Telegram habilitado mas token/admin_id n√£o configurados")
    
    async def _setup_mcp_webhook(self) -> None:
        """Configura webhook atrav√©s do MCP Server"""
        telegram_config = self.config_service.get_section("telegram")
        webhook_config = telegram_config.get("webhook", {})
        
        if webhook_config.get("enabled") and webhook_config.get("url"):
            try:
                result = await self.mcp_client.call_tool(
                    "telegram-bot", 
                    "setup-webhook",
                    {
                        "webhook_url": webhook_config["url"],
                        "secret_token": webhook_config.get("secret_token", "")
                    }
                )
                
                if result.get("success"):
                    print("üåê Webhook Telegram configurado via MCP!")
                else:
                    print(f"‚ö†Ô∏è Erro no webhook: {result.get('error')}")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao configurar webhook: {e}")
    
    async def _register_event_handlers(self) -> None:
        """Registra handlers para eventos do sistema"""
        # Handler para an√°lise de projeto completada
        self.register_event_handler("project_analyzed", self._on_project_analyzed)
        
        # Handler para anomalias detectadas  
        self.register_event_handler("anomalies_detected", self._on_anomalies_detected)
        
        # Handler para comandos MCP
        self.register_event_handler("mcp_command_received", self._on_mcp_command)
    
    
    async def _on_mcp_command(self, event) -> None:
        """Handler para comandos recebidos via MCP"""
        if not self._telegram_server_active:
            return
            
        command_data = event.data
        command = command_data.get("command")
        args = command_data.get("args", [])
        
        try:
            # Rota comando atrav√©s do MCP Server
            result = await self.mcp_client.call_tool(
                "telegram-bot",
                "handle-telegram-command", 
                {
                    "command": command,
                    "args": args,
                    "user_id": command_data.get("user_id"),
                    "chat_id": command_data.get("chat_id")
                }
            )
            
            if result.get("success"):
                print(f"üì± Comando MCP processado: {command}")
            else:
                print(f"‚ö†Ô∏è Erro no comando MCP: {result.get('error')}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao processar comando MCP: {e}")

    async def _on_project_analyzed(self, event) -> None:
        """Handler melhorado com integra√ß√£o MCP"""
        if not self._should_send_notification("project_analysis"):
            return
            
        analysis: ProjectInfo = event.data.get("analysis")
        if analysis:
            # M√©todo tradicional (fallback)
            if self.telegram_service:
                message = self._format_analysis_message(analysis)
                await asyncio.create_task(self._send_async_message(message))
            
            # M√©todo MCP (preferred)
            if self._telegram_server_active:
                try:
                    result = await self.mcp_client.call_tool(
                        "telegram-bot",
                        "send-project-report",
                        {
                            "project_path": getattr(analysis, 'project_path', '.'),
                            "include_ai": True,
                            "include_suggestions": True
                        }
                    )
                    
                    if result.get("success"):
                        print("üì± Relat√≥rio enviado via MCP Server!")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro MCP fallback para m√©todo tradicional: {e}")
    
    async def _on_anomalies_detected(self, event) -> None:
        """Handler para quando anomalias s√£o detectadas"""
        if not self._should_send_notification("anomalies"):
            return
            
        anomalies = event.data.get("anomalies", {})
        project_name = event.data.get("project_name", "Unknown")
        
        if anomalies and self.telegram_service:
            success = self.telegram_service.send_anomaly_alert(anomalies, project_name)
            if success:
                print("üì± Alerta Telegram enviado")
    
    def _should_send_notification(self, notification_type: str) -> bool:
        """Verifica se deve enviar notifica√ß√£o do tipo especificado"""
        if not self.telegram_service or not self.telegram_service.is_available():
            return False
            
        telegram_config = self.config_service.get_section("telegram")
        notifications = telegram_config.get("notifications", {})
        
        return notifications.get(notification_type, True)
    
    def _format_analysis_message(self, analysis: ProjectInfo) -> str:
        """Formata mensagem de an√°lise de projeto"""
        score = analysis.quality_score
        score_emoji = "üü¢" if score >= 8 else "üü°" if score >= 6 else "üî¥"
        
        message = f"üìä *An√°lise XKit Conclu√≠da*\n\n"
        message += f"üìÅ Projeto: `{analysis.project_name}`\n"
        message += f"{score_emoji} Qualidade: **{score:.1f}/10**\n\n"
        
        # Adiciona m√©tricas principais
        if analysis.metrics:
            message += f"üìà *M√©tricas:*\n"
            message += f"‚Ä¢ Arquivos: {analysis.metrics.total_files}\n"
            message += f"‚Ä¢ Documenta√ß√£o: {'‚úÖ' if analysis.metrics.documentation_files > 0 else '‚ùå'}\n"
            message += f"‚Ä¢ Git: {'‚úÖ' if analysis.metrics.has_git else '‚ùå'}\n"
        
        # Adiciona tecnologias detectadas
        if analysis.technologies:
            tech_line = " ".join([f"#{tech.lower()}" for tech in analysis.technologies[:3]])
            message += f"\nüõ†Ô∏è {tech_line}\n"
        
        return message
    
    async def _send_async_message(self, message: str) -> bool:
        """Envia mensagem de forma ass√≠ncrona"""
        if self.telegram_service:
            # Executa em thread separada para n√£o bloquear
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, self.telegram_service._send_message, message)
        return False
    
    async def _send_startup_message(self) -> None:
        """Envia mensagem de inicializa√ß√£o melhorada"""
        if self._should_send_notification("startup"):
            startup_msg = "üöÄ *XKit v3.0 - Telegram Bot Ativo*\n\n"
            startup_msg += "‚úÖ Bot conectado com Hybrid MCP Architecture\n"
            startup_msg += "üîå MCP Server: " + ("‚úÖ Ativo" if self._telegram_server_active else "‚ùå Indispon√≠vel") + "\n"
            startup_msg += "üìä Relat√≥rios autom√°ticos de an√°lise ativados\n\n"
            startup_msg += "*Comandos dispon√≠veis:*\n"
            startup_msg += "‚Ä¢ /analyze - Analisar projeto\n"
            startup_msg += "‚Ä¢ /status - Status do sistema\n"
            startup_msg += "‚Ä¢ /git - Status Git\n"
            startup_msg += "‚Ä¢ /help - Lista de comandos"
            
            await self._send_async_message(startup_msg)
    
    # MCP Integration Methods
    async def send_system_status(self) -> bool:
        """Envia status do sistema via MCP"""
        if not self._telegram_server_active:
            return False
            
        try:
            result = await self.mcp_client.call_tool(
                "telegram-bot",
                "send-system-status",
                {
                    "include_plugins": True,
                    "include_mcp": True
                }
            )
            return result.get("success", False)
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao enviar status via MCP: {e}")
            return False
    
    async def analyze_and_send_project(self, project_path: str = ".") -> bool:
        """Analisa projeto e envia via MCP"""
        if not self._telegram_server_active:
            return False
            
        try:
            result = await self.mcp_client.call_tool(
                "telegram-bot",
                "send-project-report",
                {
                    "project_path": project_path,
                    "include_ai": True,
                    "include_suggestions": True
                }
            )
            return result.get("success", False)
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao analisar via MCP: {e}")
            return False
    
    async def send_git_status(self, repo_path: str = ".") -> bool:
        """Envia status Git via MCP"""
        if not self._telegram_server_active:
            return False
            
        try:
            result = await self.mcp_client.call_tool(
                "telegram-bot",
                "send-git-status", 
                {
                    "repo_path": repo_path,
                    "detailed": True
                }
            )
            return result.get("success", False)
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao enviar Git status via MCP: {e}")
            return False
    
    def get_commands(self) -> Dict[str, Callable]:
        """Retorna comandos dispon√≠veis do plugin"""
        return {
            "telegram-status": self.cmd_telegram_status,
            "telegram-test": self.cmd_telegram_test,
            "telegram-config": self.cmd_telegram_config
        }
    
    async def cmd_telegram_status(self, *args) -> None:
        """Comando para verificar status do Telegram"""
        if not self.telegram_service:
            print("ü§ñ Telegram n√£o configurado")
            print("üìù Configure em ~/.xkit/config.json")
            return
        
        if self.telegram_service.is_available():
            print("ü§ñ Telegram Bot: ‚úÖ Conectado")
            print(f"üì± Admin ID: {self.telegram_service.admin_id}")
        else:
            print("ü§ñ Telegram Bot: ‚ùå N√£o dispon√≠vel")
            print("‚ö†Ô∏è Verifique token e admin_id")
    
    async def cmd_telegram_test(self, *args) -> None:
        """Comando para testar envio de mensagem"""
        if not self.telegram_service or not self.telegram_service.is_available():
            print("ü§ñ Telegram n√£o dispon√≠vel para teste")
            return
        
        test_message = "üß™ *Teste XKit Telegram Plugin*\n\n"
        test_message += "‚úÖ Plugin funcionando corretamente!"
        
        success = await self._send_async_message(test_message)
        if success:
            print("üì± Mensagem de teste enviada!")
        else:
            print("‚ùå Falha ao enviar mensagem de teste")
    
    async def cmd_telegram_config(self, *args) -> None:
        """Comando para exibir configura√ß√£o atual"""
        telegram_config = self.config_service.get_section("telegram")
        
        if not telegram_config:
            print("ü§ñ Telegram n√£o configurado")
            return
        
        print("ü§ñ *Configura√ß√£o Telegram:*")
        print(f"   Habilitado: {'‚úÖ' if telegram_config.get('enabled') else '‚ùå'}")
        print(f"   Token: {'‚úÖ Configurado' if telegram_config.get('token') else '‚ùå N√£o configurado'}")
        print(f"   Admin ID: {'‚úÖ Configurado' if telegram_config.get('admin_id') else '‚ùå N√£o configurado'}")
        
        notifications = telegram_config.get("notifications", {})
        print("üì¢ *Notifica√ß√µes:*")
        for notif_type, enabled in notifications.items():
            status = "‚úÖ" if enabled else "‚ùå"
            print(f"   {notif_type}: {status}")